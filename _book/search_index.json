[["index.html", "", " Analisis de Datos en R M.Sc. Esteban Ballestero Alfaro Esteban Ballestero Alfaro Profesor de Matemáticas Escuela de Ciencias Naturales y Exactas Instituto Tecnológico de Costa Rica, Campus Tecnológico Local San Carlos Fecha de publicación: 30 de octubre de 2024 "],["correlaciones-y-graficos-con-correlaciones.html", "1 Correlaciones y graficos con correlaciones 1.1 ¿Qué tipo de objeto es c? 1.2 Pasamos a la sección de modelaje.", " 1 Correlaciones y graficos con correlaciones library(corrplot) # paquete para crear gráficos de correlaciones library(corrr) # para usar la función correlate library(ggcorrplot) # paquete para crear gráficos de correlaciones library(tidyverse) # Caraga contiene varias funciones y ggplot2, al cargarlo se cargan todas. Si solo se desea usar ggplot 2, puede cargarse por separado library(GGally) # para usar la función ggcorr() library(visreg) # paquete para hacer una exloración inicial de los datos library(DataExplorer) #Para usar la función plot_missing library(visdat) Traemos un set de datos para trabajar data(&quot;airquality&quot;) vis_data permite rápidamente identificar la cantidad de NA, pero además, hace una clasificación de tods los tipos de variables presentes en los datos. vis_dat(airquality) aire &lt;- na.omit(airquality) vis_dat(aire) La función cor viene por defecto en R, no se requiere de paquete alguno. Algunos paquetes trabajan la correlación, pero con otras herramientas adicionales c &lt;- cor(aire) c ## Ozone Solar.R Wind Temp Month ## Ozone 1.000000000 0.34834169 -0.61249658 0.6985414 0.142885168 ## Solar.R 0.348341693 1.00000000 -0.12718345 0.2940876 -0.074066683 ## Wind -0.612496576 -0.12718345 1.00000000 -0.4971897 -0.194495804 ## Temp 0.698541410 0.29408764 -0.49718972 1.0000000 0.403971709 ## Month 0.142885168 -0.07406668 -0.19449580 0.4039717 1.000000000 ## Day -0.005189769 -0.05775380 0.04987102 -0.0965458 -0.009001079 ## Day ## Ozone -0.005189769 ## Solar.R -0.057753801 ## Wind 0.049871017 ## Temp -0.096545800 ## Month -0.009001079 ## Day 1.000000000 Como aparecen los datos con varios decimales, se puede reducir el número de decimales aplicando un redondeo: c &lt;- round(cor(aire),2) # Se almacena esta correlación en una variable c c ## Ozone Solar.R Wind Temp Month Day ## Ozone 1.00 0.35 -0.61 0.70 0.14 -0.01 ## Solar.R 0.35 1.00 -0.13 0.29 -0.07 -0.06 ## Wind -0.61 -0.13 1.00 -0.50 -0.19 0.05 ## Temp 0.70 0.29 -0.50 1.00 0.40 -0.10 ## Month 0.14 -0.07 -0.19 0.40 1.00 -0.01 ## Day -0.01 -0.06 0.05 -0.10 -0.01 1.00 1.1 ¿Qué tipo de objeto es c? class(c) ## [1] &quot;matrix&quot; &quot;array&quot; Note que c es una matriz, por tanto no se puede trabajar en ggplot2, por lo que primeramente se debe transformar cen otro tipo de objeto llamado dataframe. Hay paquetes como cor, que usamos previamente, que hace el cambio a dataframe de manera interna automáticamente, pero otros requieren de una previa transformación: c_df &lt;- as.data.frame(c) c_df ## Ozone Solar.R Wind Temp Month Day ## Ozone 1.00 0.35 -0.61 0.70 0.14 -0.01 ## Solar.R 0.35 1.00 -0.13 0.29 -0.07 -0.06 ## Wind -0.61 -0.13 1.00 -0.50 -0.19 0.05 ## Temp 0.70 0.29 -0.50 1.00 0.40 -0.10 ## Month 0.14 -0.07 -0.19 0.40 1.00 -0.01 ## Day -0.01 -0.06 0.05 -0.10 -0.01 1.00 class(c_df) ## [1] &quot;data.frame&quot; El siguiente caso, corrplot, puede trabajar con la matriz, sin necesidad de cinvertirla en dataframe corrplot(c) corrplot(c, method = &quot;number&quot;) corrplot(c, method = &quot;square&quot;) corrplot(c, method = &quot;ellipse&quot;) corrplot(c, method = &quot;pie&quot;) corrplot(c, method = &quot;shade&quot;) En los gráficos anteriores, note que la matriz es simétrica con respecto a la diagonal principal, por lo que tanto arriba de ella como debajo de ella, tendríamos la misma información. Según los gustos del analista de datos, podría únicamente considerar trabajar con solamente con el triángulo superior o el triángulo inferior como se muestra a continuación corrplot(c, method = &quot;shade&quot;, type = &quot;upper&quot;) corrplot(c, method = &quot;shade&quot;, type = &quot;low&quot;) Otras funciones que trabajan directamente con la matriz de correlaciones: ggcorrplot(c) ggcorrplot(c, method = &quot;circle&quot;) ggcorrplot(c, method = &quot;square&quot;, lab = TRUE) Seguidamente usamos la función correlate() del paquete corrr, para crear una correlación tipo dataframe correlate(aire) ## Correlation computed with ## • Method: &#39;pearson&#39; ## • Missing treated using: &#39;pairwise.complete.obs&#39; ## # A tibble: 6 × 7 ## term Ozone Solar.R Wind Temp Month Day ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ozone NA 0.348 -0.612 0.699 0.143 -0.00519 ## 2 Solar.R 0.348 NA -0.127 0.294 -0.0741 -0.0578 ## 3 Wind -0.612 -0.127 NA -0.497 -0.194 0.0499 ## 4 Temp 0.699 0.294 -0.497 NA 0.404 -0.0965 ## 5 Month 0.143 -0.0741 -0.194 0.404 NA -0.00900 ## 6 Day -0.00519 -0.0578 0.0499 -0.0965 -0.00900 NA cor_df &lt;- correlate(aire) ## Correlation computed with ## • Method: &#39;pearson&#39; ## • Missing treated using: &#39;pairwise.complete.obs&#39; cor_df ## # A tibble: 6 × 7 ## term Ozone Solar.R Wind Temp Month Day ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ozone NA 0.348 -0.612 0.699 0.143 -0.00519 ## 2 Solar.R 0.348 NA -0.127 0.294 -0.0741 -0.0578 ## 3 Wind -0.612 -0.127 NA -0.497 -0.194 0.0499 ## 4 Temp 0.699 0.294 -0.497 NA 0.404 -0.0965 ## 5 Month 0.143 -0.0741 -0.194 0.404 NA -0.00900 ## 6 Day -0.00519 -0.0578 0.0499 -0.0965 -0.00900 NA class(cor_df) ## [1] &quot;cor_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; rplot(cor_df) rplot(cor_df, colours = c(&quot;yellow&quot;,&quot;white&quot;,&quot;red&quot;)) Cambiando el número de shape, se pueden ver otras formas rplot(cor_df, shape = 2, colours = c(&quot;yellow&quot;,&quot;white&quot;,&quot;red&quot;)) rplot(cor_df, shape = 2, colours = c(&quot;yellow&quot;,&quot;white&quot;,&quot;red&quot;), print_cor = TRUE) El siguiente gráfico es una variante para ilustrar correlaciones, a partir de flechas que señalan las conexiones entre las diferentes variables: # La función network_plot, pertenece al paquete corrr network_plot(cor_df) Nota, variable Ozone, tiene la primera “O” en mayúscula focus(cor_df, Ozone) ## # A tibble: 5 × 2 ## term Ozone ## &lt;chr&gt; &lt;dbl&gt; ## 1 Solar.R 0.348 ## 2 Wind -0.612 ## 3 Temp 0.699 ## 4 Month 0.143 ## 5 Day -0.00519 Se puede cambiar el nivel de tolerancia de la correlación, para que muestre en la gráfico solamente las correlaciones que estén por debajo de ese mínimo # min_cor indica un mínimo para la correlación. Las variables con correlación por debajo de este mínimo, no serán representadas en el gráfico. network_plot(cor_df, min_cor = 0.1) Usando el paquete GGally, con la matriz c ggcorr(c) ggcorr(c, label = TRUE, lavel_alpha = TRUE) cor.test(aire$Ozone, aire$Temp) ## ## Pearson&#39;s product-moment correlation ## ## data: aire$Ozone and aire$Temp ## t = 10.192, df = 109, p-value &lt; 2.2e-16 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.5888139 0.7829869 ## sample estimates: ## cor ## 0.6985414 Me indica que la correlación es diferente de cero, algo que se puede ver con el Intervalo de Confianza. Lo más útil es el intervalo de confianza Para ver un scatter plot y ver las relaciones que se dan entre las variables, se puede realizar los siguiente: ggpairs(aire) Para eliminar el mensaje extenso que aparece, usar como sigue: ggpairs(aire) Lo que aparece en las diagonales, son un density plot de cada variable de manera individual. La matriz es simétrica, por lo que a los lados de la diagonal se puede ver el gráfico de dispersión con sus correlaciones Seguidamente se crea un gráfico de dispersión entre la variables Temp y Ozone g9 &lt;- ggplot(aire, aes(x = Temp, y = Ozone)) g9 + geom_point() Gráfico de dispersión de la variable del Ozone con respecto a wind g9 &lt;- ggplot(aire, aes(x = Wind, y = Ozone)) g9 + geom_point() 1.2 Pasamos a la sección de modelaje. Buscaremos seguidamente un modelo de regresión para ajustar los datos: Variable Respuesta (equivale a la conocida variable dependiente) vs variables explicativas (conocida como variable independiente). En correlación no importa el orden de esta relación de las variables, pero en caso de regresión, sí es importante el orden las variables. Variable de respuesta: se les llamaba variable dependiente, pero en estadística no se acostumbra usar ese nombre: Response variable vs explaining variable, parece que es como una nueva nomemclatura que aparece en los artículos modernos. # La función lm crea un modelo lineal (Lineal Model) mod1 &lt;- lm(Ozone~Temp, data = aire) summary(mod1) ## ## Call: ## lm(formula = Ozone ~ Temp, data = aire) ## ## Residuals: ## Min 1Q Median 3Q Max ## -40.922 -17.459 -0.874 10.444 118.078 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -147.6461 18.7553 -7.872 2.76e-12 *** ## Temp 2.4391 0.2393 10.192 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 23.92 on 109 degrees of freedom ## Multiple R-squared: 0.488, Adjusted R-squared: 0.4833 ## F-statistic: 103.9 on 1 and 109 DF, p-value: &lt; 2.2e-16 Los datos que muestra es para un modelo de y= a + bx. Los asteriscos que aparecen se explican en singnif. codes Seguidamente, se grafica el modelo lineal usando ggplot2 g9 &lt;- ggplot(aire, aes(x = Temp, y = Ozone)) g9 + geom_point() + geom_smooth(method = &quot;lm&quot;) ## `geom_smooth()` using formula = &#39;y ~ x&#39; Se puede usar línea suavisada, la cuál si se diferencia de mucho de la recta, es posible que la correlación no sea lineal g9 &lt;- ggplot(aire, aes(x = Temp, y = Ozone)) g9 + geom_point() + geom_smooth(method = &quot;lm&quot;) + geom_smooth() ## `geom_smooth()` using formula = &#39;y ~ x&#39; ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; Otro caso es la relación de viento con ozono, note que el smooth o línea suavisada, toma una curvatura que difiere mucho de la línea recta. g9 &lt;- ggplot(aire, aes(x = Wind, y = Ozone)) g9 + geom_point() + geom_smooth(method = &quot;lm&quot;) + geom_smooth() ## `geom_smooth()` using formula = &#39;y ~ x&#39; ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; # Se puede tener acceso al intervalo de confianza del modelo que se creó previamente mod1 confint(mod1) ## 2.5 % 97.5 % ## (Intercept) -184.818372 -110.473773 ## Temp 1.964787 2.913433 "],["practica-utilizando-astasa-anexos.html", "2 Practica utilizando astasa (Anexos)", " 2 Practica utilizando astasa (Anexos) Esto es una práctica para poder usar el paquete astasa library(astsa) data(&quot;climhyd&quot;) vis_dat(climhyd) Lake Shasta inflow data Description Lake Shasta inflow data This is a data frame. Format A data frame with 454 observations (rows) on the following 6 numeric variables (columns): Temp, DewPt, CldCvr, WndSpd, Precip, Inflow. Details The data are 454 months of measured values for the climatic variables: air temperature, dew point, cloud cover, wind speed, precipitation, and inflow, at Lake Shasta, California. The man-made lake is famous for the placard stating, “We don’t swim in your toilet, so don’t pee in our lake.” data(&quot;fmri&quot;) fmri {astsa} R Documentation fMRI - complete data set Description Data (as a vector list) from an fMRI experiment in pain, listed by location and stimulus. The data are BOLD signals when a stimulus was applied for 32 seconds and then stopped for 32 seconds. The signal period is 64 seconds and the sampling rate was one observation every 2 seconds for 256 seconds (n = 128). The number of subjects under each condition varies. Details The LOCATIONS of the brain where the signal was measured were [1] Cortex 1: Primary Somatosensory, Contralateral, [2] Cortex 2: Primary Somatosensory, Ipsilateral, [3] Cortex 3: Secondary Somatosensory, Contralateral, [4] Cortex 4: Secondary Somatosensory, Ipsilateral, [5] Caudate, [6] Thalamus 1: Contralateral, [7] Thalamus 2: Ipsilateral, [8] Cerebellum 1: Contralateral and [9] Cerebellum 2: Ipsilateral. The TREATMENTS or stimuli (and number of subjects in each condition) are [1] Awake-Brush (5 subjects), [2] Awake-Heat (4 subjects), [3] Awake-Shock (5 subjects), [4] Low-Brush (3 subjects), [5] Low-Heat (5 subjects), and [6] Low-Shock (4 subjects). Issue the command summary(fmri) for further details. In particular, awake (Awake) or mildly anesthetized (Low) subjects were subjected levels of periodic brushing (Brush), application of heat (Heat), and mild shock (Shock) effects. As an example, fmri$L1T6 (Location 1, Treatment 6) will show the data for the four subjects receiving the Low-Shock treatment at the Cortex 1 location; note that fmri[[6]] will display the same data. "],["exploracion-y-visualización-de-datos.html", "3 Exploracion y Visualización de Datos 3.1 Exploración de datos 3.2 Una mirada a los datos 3.3 Atipicidades 3.4 Una mirada a las correlaciones 3.5 Bases para la regresion", " 3 Exploracion y Visualización de Datos 3.1 Exploración de datos Una de las buenas prácticas que se recomienda implementar a la hora de analizar datos, es iniciar haciendo una mirada a estos de manera que desde el inicio, se pueda tener un visión general de la materia prima con la que se pretende trabajar. 3.1.1 ¿Que interesa conocer de los datos? Cada analista podría definir sus propias prioridades, pero posiblemente se pueda tener un consenso en lo siguiente: tipos de datos, las variables, datos atípicos, celdas vacías, tamaño de la base de datos, estructura general de la base de datos, entre otras. En R podemos echar mano de varias herramientas exploratorias de consulta o de tipo gráficas, que rápidamente permiten tener ese panorama general. 3.2 Una mirada a los datos Primeramente creamos un primer chunk para cargar los paquetes o librerías de R requeridos para el trabajo con los datos: library(visdat) # Paquete con varias herramientas para visualizar datos library(DataExplorer) #Para usar la función plot_missing library(mosaicData) # Paquete que contiene bases de datos library(ggplot2) # paquete graficador de alto desempeño library(colorspace) # Paleta de colores library(dplyr) #para usar funciones de ordenamiento, selección, agrupación library(GGally) library(tidyr) # para usar la función drop_na library(correlation) # para calcular correlaciones library(PerformanceAnalytics) library(psych) library(ggraph) R posee algunas bases de datos de uso libre, de las cuáles en esta oportunidad se cargará la base de datos airquality la cuál contiene datos ambientales. En RStudio podemos consultar la ayuda si se desea saber información sobre algún paquete, una función o alguna base de datos. La siguiente instrucción permite acceder a la ayuda para conocer cómo está cosntituida la base de datos airquality: ?airquality Seguidamente se carga la base de datos: data(&quot;airquality&quot;) #Base de datos con variables que estudian la calidad del aire Se puede ver un resumen sobre como está constituida dicha base de datos con las siguientes indicaciones: head(airquality) ## Ozone Solar.R Wind Temp Month Day ## 1 41 190 7.4 67 5 1 ## 2 36 118 8.0 72 5 2 ## 3 12 149 12.6 74 5 3 ## 4 18 313 11.5 62 5 4 ## 5 NA NA 14.3 56 5 5 ## 6 28 NA 14.9 66 5 6 summary(airquality) ## Ozone Solar.R Wind Temp ## Min. : 1.00 Min. : 7.0 Min. : 1.700 Min. :56.00 ## 1st Qu.: 18.00 1st Qu.:115.8 1st Qu.: 7.400 1st Qu.:72.00 ## Median : 31.50 Median :205.0 Median : 9.700 Median :79.00 ## Mean : 42.13 Mean :185.9 Mean : 9.958 Mean :77.88 ## 3rd Qu.: 63.25 3rd Qu.:258.8 3rd Qu.:11.500 3rd Qu.:85.00 ## Max. :168.00 Max. :334.0 Max. :20.700 Max. :97.00 ## NA&#39;s :37 NA&#39;s :7 ## Month Day ## Min. :5.000 Min. : 1.0 ## 1st Qu.:6.000 1st Qu.: 8.0 ## Median :7.000 Median :16.0 ## Mean :6.993 Mean :15.8 ## 3rd Qu.:8.000 3rd Qu.:23.0 ## Max. :9.000 Max. :31.0 ## str(airquality) ## &#39;data.frame&#39;: 153 obs. of 6 variables: ## $ Ozone : int 41 36 12 18 NA 28 23 19 8 NA ... ## $ Solar.R: int 190 118 149 313 NA NA 299 99 19 194 ... ## $ Wind : num 7.4 8 12.6 11.5 14.3 14.9 8.6 13.8 20.1 8.6 ... ## $ Temp : int 67 72 74 62 56 66 65 59 61 69 ... ## $ Month : int 5 5 5 5 5 5 5 5 5 5 ... ## $ Day : int 1 2 3 4 5 6 7 8 9 10 ... Usando el paquete visdat, hacemos una exploración gráfica de la base de datos: vis_dat(airquality) vis_guess(airquality) vis_miss(airquality) plot_missing(airquality) # Me indica si tenemos datos en blanco y me da una recomendación, que en este caso dice que es &quot;Good y Ok&quot;, lo cual no es mucho problema # Use ?plot_missing() si desea conocer más sobre esta función Si se desea, se pueden omitir los datos NA, pero al implicar este procedimiento una modificación de la base de datos original, se recomienda crear una nueva variable de almacenamiento, como se muestra en el siguiente chunk: aire &lt;- na.omit(airquality) vis_dat(aire) 3.3 Atipicidades Para el estudio de las tipicidades, se echará mano de dos tipos de gráficos del paquete ggplot2: Diagramas de caja (boxplot) y gráficos de violín (Violinplot). El paquete ggplot2 es uno de los paquetes más completos que tiene R para generar gráficos diversos y de alta complejidad y calidad, el cuál trabaja bajo una filosofía de Grammar of Graphs (Gramática de gráficos) que permite contruir los gráficos a partir de capas. Primeramente se crea el marco de trabajo base (Primera capa), el cuál al contener solo la base de datos cargada, no mostrará ningún elemento visual: ggplot(aire, aes(Month)) Ahora, se agrega una segunda capa de tipo geom_boxplot ggplot(aire, aes(Month,Ozone )) + geom_boxplot(alpha = 0.4, color = &quot;blue&quot;, aes(group = cut_width(Month, 1))) En el gráfico anterior se puede notar que en el horizontal aparecen los meses dados por número de mes, pero podría ser interesante verlo con nombre del mes. El siguiente código crea una nueva columna en la base de datos con el nombre del mes aire$Mes &lt;- ifelse(aire$Month == 5, &quot;Mayo&quot;, ifelse (aire$Month == 6, &quot;Junio&quot;, ifelse(aire$Month == 7,&quot;Julio&quot;, ifelse(aire$Month == 8, &quot;Agosto&quot;,&quot;Septiembre&quot;) ) ) ) aire$Mes &lt;- factor(aire$Mes, levels = c(&quot;Mayo&quot;,&quot;Junio&quot;,&quot;Julio&quot;,&quot;Agosto&quot;,&quot;Septiembre&quot;)) Seguidamente crearemos el mismo diagrama de caja, pero usando la nueva columnna ggplot(aire, aes(Mes, Ozone)) + geom_boxplot(alpha = 0.4, color = &quot;dodgerblue4&quot;, outlier.shape = 19) Los datos atípicos se muestran como puntos fuera de la caja, pero esa forma podría cambiar a gusto del usuario. En el siguiente enlace puede ver un compendio de variantes para la figura que podría usarse para representar los puntos en R Figuras para puntos ggplot2 La siguiente variante del diagrama de caja puede ser más interesante: ggplot(aire, aes(Mes, Ozone)) + geom_boxplot(alpha = 0.4, color = &quot;dodgerblue4&quot;, outlier.shape = 19, outlier.color = &quot;red&quot;, aes(fill = Month)) + geom_point(alpha = 0.2) Agreguemos otros elementos importantes en un gráfico, como título: ggplot(aire, aes(Mes, Ozone)) + geom_boxplot(alpha = 0.4, color = &quot;dodgerblue4&quot;, outlier.shape = 19, outlier.color = &quot;red&quot;, aes(fill = Month))+ labs(title = &quot;Media diaria de Ozono en ppm, por mes&quot;, subtitle = &quot;Roosevel Island según mes, del 1 de mayo al 30 de septiembre 1973&quot;, y = &quot;Ozono&quot;) Otra variante interesante del diagrama de caja que se viene utilizando, es el gráfico de violín o violin plot, el cuál presenta la ventaja de que permite conocer la distribución de los datos durante el recorrido. Antes de constuir nuestro primer violin plot, podemos simplificar el código almacenando instrucciones de uso frecuente, como seguidamente se muestra: # g1 es una variables que almacena la primera capa del gráfico a crear g1 &lt;- ggplot(aire, aes(Mes, Ozone)) Los violinplot son un tipo de función de densidad (density plot) para los datos vistos desde arriba.este gráfico se está prefiriendo sobre el box plot, porque permite ver en el recorrido la forma en que se agrupan o se concentran los datos. No es necesario, para efectos de publicación, presentarlo junto con la caja. Seguidamente, se construye el violin plot: g1 + geom_violin(aes(fill = Month, alpha = 0.3)) Se puede agregar los puntos para verlos superpuestos al violinplot: g1 + geom_jitter(width = 0.3, alpha = 0.4) + geom_violin(aes(fill = Month, alpha = 0.3)) Se puede superponer además con los box plot: g1 + geom_jitter(width = 0.3, alpha = 0.4) + geom_boxplot(alpha = 0.4, color = &quot;blue&quot;) + geom_violin(aes(alpha = 0.3, fill = Month)) En el siguiente código se propone crear algunas estadísticas para los datos agrupados: cantidad de datos, desviación estándar, error estándar y lo límites superior e inferior para el intervalo de confianza para dicha media, con el objetico de incluirlos dentro del gráfico que se viene trabajando. Para este trabajo se utilizará el operador pipe %&gt;% que permite crear acciones anidadas: est &lt;- aire %&gt;% group_by(Mes) %&gt;% summarise(media = mean(Ozone), n = n(), de = sd(Ozone), ee = de/sqrt(n()), li = media - 1.96*ee, ls = media +1.96*ee ) est ## # A tibble: 5 × 7 ## Mes media n de ee li ls ## &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mayo 24.1 24 22.9 4.67 15.0 33.3 ## 2 Junio 29.4 9 18.2 6.07 17.5 41.3 ## 3 Julio 59.1 26 31.6 6.20 47.0 71.3 ## 4 Agosto 60 23 41.8 8.71 42.9 77.1 ## 5 Septiembre 31.4 29 24.1 4.48 22.7 40.2 Se procede a incluir estas nuevas estadísticas al gráfico: g1 + geom_jitter(width = 0.3, alpha = 0.4) + geom_boxplot() + geom_violin(aes(alpha = 0.3, fill = Month)) + theme_minimal() + geom_point(data = est, aes(Mes, media)) + geom_errorbar(data = est, aes(Mes, media, ymin = li, ymax = ls), width = 0.2, color =&quot;red&quot;) Los gráficos de barras y una variante conocida como lollipops podrín ser útiles en el conteo de datos: ggplot(aire, aes(Mes)) + geom_bar(aes(fill = Month)) mescont &lt;- aire %&gt;% group_by(Mes) %&gt;% summarize(conteo = n() ) ggplot(mescont, aes(Mes, conteo)) + geom_col(fill = &quot;steelblue&quot;, width = 0.015) + geom_point(color = &quot;darkorange&quot;, size = 5) + geom_text(aes(label = conteo), size = 2) 3.4 Una mirada a las correlaciones R permite constuir matrices gráficas con información variada de los datos, como por ejemplo los gráficos de densidad, gráfico de dispersión y correlaciones que facilitan ese acercamiento a la base de datos a trabajar. Este gráfico se construye con el paquete GGally: ggpairs(datos[filas, c(“Columna 1”, “Columna2”,…, “Columna n”)]) ggpairs(aire[, c(&quot;Ozone&quot;, &quot;Solar.R&quot;,&quot;Wind&quot;, &quot;Temp&quot;)]) Veamos otras opciones de matrices de gráficos de resumen de datos usando los paquetes peformanceanalitycs y psych: chart.Correlation(aire[, c(&quot;Ozone&quot;, &quot;Solar.R&quot;,&quot;Wind&quot;, &quot;Temp&quot;)], histogram=TRUE, pch=19) ## Warning in par(usr): argument 1 does not name a graphical parameter ## Warning in par(usr): argument 1 does not name a graphical parameter ## Warning in par(usr): argument 1 does not name a graphical parameter ## Warning in par(usr): argument 1 does not name a graphical parameter ## Warning in par(usr): argument 1 does not name a graphical parameter ## Warning in par(usr): argument 1 does not name a graphical parameter pairs.panels(aire[, c(&quot;Ozone&quot;, &quot;Solar.R&quot;,&quot;Wind&quot;, &quot;Temp&quot;)], scale=TRUE) Seguidamente se hace un análisis para las correlaciones, la idea es ver si entre las variables numéricas presentes existe algún tipo de correlación fuerte. Primeramente, trabajaremos con la base de datos original, es decir, sin la nueva columna creada para el Mes: calidadaire &lt;- na.omit(airquality) head(calidadaire) ## Ozone Solar.R Wind Temp Month Day ## 1 41 190 7.4 67 5 1 ## 2 36 118 8.0 72 5 2 ## 3 12 149 12.6 74 5 3 ## 4 18 313 11.5 62 5 4 ## 7 23 299 8.6 65 5 7 ## 8 19 99 13.8 59 5 8 Podemos usar el operador pipe para filtar nuestra base de datos, como se muestra acontinuación: calidadaire &lt;- airquality %&gt;% # se indica cuál es la base de datos usada drop_na() %&gt;% # se eliminan los na, toda la fila dplyr::select(-c(Month, Day)) # eliminamos las columnas Month y Day Es importante explicar el significado de la instrucción dplyr::select. Ocurre con frecuencia en R que muchos paquetes podrían tener una función con el mismo nombre, entonces, cuando se llama a la función, que en este ejemplo es select, y queremos que sea select del paquete dplyr específicamente y no de otro paquete, entonces se debe indicar el nombre del paquete seguido por el operardor :: y luego la función a usar. Note que los datos ya no contienen las celdas vacías ni tampoco las columnas de Month y Day. Es importante tomar en cuenta que la correlación lineal es una métrica sobre la relación lineal entre dos variables, no es un modelo como si lo es una regresión lineal. Hay varias formas de ver las correlaciones en R, seguidamente se presentan varias opciones: cor &lt;- correlation(calidadaire) cor ## # Correlation Matrix (pearson-method) ## ## Parameter1 | Parameter2 | r | 95% CI | t(109) | p ## --------------------------------------------------------------------- ## Ozone | Solar.R | 0.35 | [ 0.17, 0.50] | 3.88 | &lt; .001*** ## Ozone | Wind | -0.61 | [-0.72, -0.48] | -8.09 | &lt; .001*** ## Ozone | Temp | 0.70 | [ 0.59, 0.78] | 10.19 | &lt; .001*** ## Solar.R | Wind | -0.13 | [-0.31, 0.06] | -1.34 | 0.183 ## Solar.R | Temp | 0.29 | [ 0.11, 0.46] | 3.21 | 0.003** ## Wind | Temp | -0.50 | [-0.63, -0.34] | -5.98 | &lt; .001*** ## ## p-value adjustment method: Holm (1979) ## Observations: 111 Podríamos resumir esta tabla: summary(cor) ## # Correlation Matrix (pearson-method) ## ## Parameter | Temp | Wind | Solar.R ## ----------------------------------------- ## Ozone | 0.70*** | -0.61*** | 0.35*** ## Solar.R | 0.29** | -0.13 | ## Wind | -0.50*** | | ## ## p-value adjustment method: Holm (1979) Graficar los datos de la matriz resultante de la correlación es posible, pero primero se debe organizar la infomración para que la función plot puede interpretarlos correctamente. Note que el resultado anterior del summary muestra una matriz triangular, pero el comando plot necesita que esta matriz sea cuadrada para poder graficar correctamente. La siguiente instrucción, permite hacer cuadrada la matriz de correlaciones: summary(cor, redundant = T) ## # Correlation Matrix (pearson-method) ## ## Parameter | Ozone | Solar.R | Wind | Temp ## ---------------------------------------------------- ## Ozone | | 0.35*** | -0.61*** | 0.70*** ## Solar.R | 0.35*** | | -0.13 | 0.29** ## Wind | -0.61*** | -0.13 | | -0.50*** ## Temp | 0.70*** | 0.29** | -0.50*** | ## ## p-value adjustment method: Holm (1979) Se podría graficar de la siguiente manera: plot(summary(cor, redundant = T), show_value = T, show_p = T) Una forma más elegante de hacer este gráfico, es a partir del operador pipe: cor %&gt;% summary(redundant =TRUE) %&gt;% plot(show_value = T, show_p = T) Se puede cambiar la forma de la geometría: cor %&gt;% summary(redundant =TRUE) %&gt;% plot(show_value = T, show_p = T, type = &quot;tile&quot;) El siguiente gráfico de correlación se base en un modelo gaussiano, requiere el paquete ggraph calidadaire %&gt;% correlation(partial = TRUE) %&gt;% plot() 3.5 Bases para la regresion ggplot(calidadaire, aes(Solar.R, Temp)) + geom_point() Con la capa stat_smooth se puede trazar una curva de mejor ajuste para los datos ggplot(calidadaire, aes(Solar.R, Temp)) + geom_point() + stat_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; Esta opción de smooth es una ayuda al ojo para encontrar patrones en los datos. Se puede usar el método lm para comparar entre el partrón anterior y como se vería una ajuste lineal: ggplot(calidadaire, aes(Solar.R, Temp)) + geom_point() + geom_smooth() + geom_smooth(method = &quot;lm&quot;) ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; ## `geom_smooth()` using formula = &#39;y ~ x&#39; Similarmente, comparemos las variables Solar.R y Wind: ggplot(calidadaire, aes(Solar.R, Wind)) + geom_point() + geom_smooth() + geom_smooth(method = &quot;lm&quot;) Otra forma de ver sl gráfico: ggplot(aire, aes(Solar.R, Wind)) + geom_point(aes(color = Mes)) + geom_smooth() + geom_smooth(method = &quot;lm&quot;) Recordemos la correlación entre estas dos variables: cor_test(calidadaire, &quot;Solar.R&quot;, &quot;Wind&quot;) ## Parameter1 | Parameter2 | r | 95% CI | t(109) | p ## ---------------------------------------------------------------- ## Solar.R | Wind | -0.13 | [-0.31, 0.06] | -1.34 | 0.183 ## ## Observations: 111 Note que el IC contempla al valor cero, por lo que podría no haber correlación lineal. "],["modelos-lineales.html", "4 Modelos Lineales 4.1 Modelo lineal general 4.2 ¿Qué es un modelo? 4.3 Regresion lineal simple 4.4 Supuesto de Normalidad 4.5 Supuesto de Homocedasticidad de varianzas 4.6 Supuesto de Independencia 4.7 Tecnicas para corregir la heterocedasticidad de varianzas", " 4 Modelos Lineales 4.1 Modelo lineal general La regresión es un modelo lineal general que puede considerarse como el origen de muchos de los modelos que se usan en estadística. 4.2 ¿Qué es un modelo? Un modelo es una descripción generalizada para analizar o explicar algo, comparamos (confrontamos) modelos con datos, evaluamos el ajuste de modelos a los datos observados Tipos de modelos lineales generales Regresión lineal simple Regresión lineal múltiple Anova (Análisis de varianza) Ancova (Análisis de covarainza) 4.3 Regresion lineal simple La regresión lineal simple describe la relación entre una variable respuesta (variable dependiente) y una variable explicativa (variable independiente). A diferencia de la correlación, donde las variables no se consideran variable respuesta o explicativa, en la regresión simple debe estar muy claro cual es la variable respuesta y cual es la variable explicativa. Por ejemplo, el peso corporal puede tener un efecto sobre la presión sanguínea, pero la presión sanguínea no puede tener un efecto sobre el peso corporal. Está muy claro quien es la varibale respuesta y cual la variable explicativa. Propósitos del modelo de regresión: Descripción: describir la relación entre la variable respuesta (\\(Y\\)) y la variable explicatoria (\\(X\\)) Explicación: cuantificar la variación de \\(Y\\) explicada por la relación con \\(X\\) Predicción: predecir nuevos valores de \\(Y\\) basados en nuevos valores de \\(X\\) Veamos un modelo de regresión simple, pero antes, carguemos los paquetes que utilizaremos en este análisis: library(tidyverse) library(rio) library(sjPlot) library(parameters) library(performance) library(see) library(lmtest) library(car) library(carData) library(sandwich) library(psych) Cargamos los datos trees que se incluyen en R. data(trees) Estos datos contienen las siguientes medidas de árboles: Girth: diámetro a la altura del pecho de los árboles en pulgadas Height: altura de los árboles en pies Volume: volumen de los árboles en pies cúbicos Lo que vamos a hacer es cambiar el nombre del conjunto de datos arboles y crear nuevas variables en español y con el sistema métrico decimal, para ellos utilizaremos la función mutate del paquete dplyr (tidyverse) Con la función mutate() podemos computar tranformaciones de variables en un data frame. A menudo, tendremos la necesidad de crear nuevas variables que se calculan a partir de variables existentes. arboles &lt;- trees %&gt;% mutate(dap = Girth*2.54, # de pulgadas a centímetros altura = Height/3.281, # de pies a metros volumen = Volume/35.315) # de pies cúbicos a metros cúbicos arboles &lt;- arboles[, c(&quot;dap&quot;, &quot;volumen&quot;,&quot;altura&quot;)] Ahora tenemos 3 nuevas variables: dap: diámetro a la altura del pecho en centímetros altura: altura de los árboles en metros volumen: volumen de los árboles en metros cúbicos Veamos los datos. Con la función head podemos ver las primeras 6 filas de los datos head(arboles) ## dap volumen altura ## 1 21.082 0.2916608 21.33496 ## 2 21.844 0.2916608 19.81103 ## 3 22.352 0.2888291 19.20146 ## 4 26.670 0.4643919 21.94453 ## 5 27.178 0.5323517 24.68760 ## 6 27.432 0.5578366 25.29717 str(arboles) ## &#39;data.frame&#39;: 31 obs. of 3 variables: ## $ dap : num 21.1 21.8 22.4 26.7 27.2 ... ## $ volumen: num 0.292 0.292 0.289 0.464 0.532 ... ## $ altura : num 21.3 19.8 19.2 21.9 24.7 ... Graficamos los datos usando el dap (diámetro a la altura del pecho) en el eje de las \\(x\\) (abscisas) y el volumen en el eje de las \\(y\\) (ordenadas). ggplot(arboles, aes(dap, volumen)) + theme_bw() + geom_point(color = &quot;dodgerblue3&quot;) Echemos un vistaso a las correlaciones entre las variables: pairs.panels(arboles, scale=TRUE) Vamos a ajustar un modelo lineal general, es decir una regresión lineal simple. Para eso usamos la función lm (linear model) regresion_simple &lt;- lm(volumen ~ dap, data = arboles) regresion_simple ## ## Call: ## lm(formula = volumen ~ dap, data = arboles) ## ## Coefficients: ## (Intercept) dap ## -1.04611 0.05648 summary(regresion_simple) ## ## Call: ## lm(formula = volumen ~ dap, data = arboles) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.228383 -0.087971 0.004303 0.098960 0.271466 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -1.046112 0.095289 -10.98 7.62e-12 *** ## dap 0.056475 0.002758 20.48 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.1204 on 29 degrees of freedom ## Multiple R-squared: 0.9353, Adjusted R-squared: 0.9331 ## F-statistic: 419.4 on 1 and 29 DF, p-value: &lt; 2.2e-16 regresion_simple$coefficients ## (Intercept) dap ## -1.04611239 0.05647548 Primero veamos lo que está pasando gráficamente ggplot(arboles, aes(dap, volumen)) + theme_bw() + geom_point(color = &quot;dodgerblue3&quot;) + geom_smooth(method = lm, se = FALSE, color = &quot;red&quot;) ## `geom_smooth()` using formula = &#39;y ~ x&#39; La línea de color rojo representa el modelo de regresión ajustado a los datos. Matemáticamente, podemos escribir la ecuación del modelo de regresión de la siguiente manera: \\(Y \\approx\\beta _0+ \\beta _1X+ \\varepsilon\\) donde: \\(Y\\) representa a la variable respuesta \\(X\\) representa la variables explicativa \\(\\beta _0\\) es el intercepto del modelo \\(\\beta _1\\) la pendiente del modelo \\(\\varepsilon\\) es el error, término que significa la variabilidad de \\(Y\\) que el modelo no puede explicar (lo que \\(X\\) no puede decirnos sobre \\(Y\\)) En nuestro ejemplo, \\(volumen ≈ intercepto + pendiente(dap) + error\\) Veamos un resumen numérico del modelo summary(regresion_simple) ## ## Call: ## lm(formula = volumen ~ dap, data = arboles) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.228383 -0.087971 0.004303 0.098960 0.271466 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -1.046112 0.095289 -10.98 7.62e-12 *** ## dap 0.056475 0.002758 20.48 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.1204 on 29 degrees of freedom ## Multiple R-squared: 0.9353, Adjusted R-squared: 0.9331 ## F-statistic: 419.4 on 1 and 29 DF, p-value: &lt; 2.2e-16 Seguidamente, echemos una mirada a los residuales del modelo. Calculemos estos valores y posteriormente, los agregaremos al gráfico: arboles$predicho &lt;- predict(regresion_simple) # guardamos los valores predicho por el modelo Seguidamente mostraremos el gáfico con datos crudos y los valores predichos: ggplot(arboles, aes(dap, volumen)) + theme_bw() + geom_smooth(method = lm, se = FALSE, color = &quot;gray&quot;) + geom_point() + geom_point(aes(y = predicho), color = &quot;red&quot;) ## `geom_smooth()` using formula = &#39;y ~ x&#39; Representamos gráficamente los residuales: ggplot(arboles, aes(dap, volumen)) + theme_bw() + geom_smooth(method = lm, se = FALSE, color = &quot;gray&quot;) + geom_point() + geom_point(aes(y = predicho), color = &quot;red&quot;) + geom_segment(aes(xend = dap, yend = predicho), color = &quot;blue&quot;) ## `geom_smooth()` using formula = &#39;y ~ x&#39; Pero todos los modelos tienen supuestos El modelo lineal general debe cumplir los siguientes supuestos para que el modelo sea interpretado y aplicado en la práctica. Supuestos de un modelo lineal general Linealidad Normalidad Homogeneidad de varianza Independencia Para verificar los supuestos debemos ver gráficos diagnósticos del modelo que permiten gráficar los residuales del modelo Linealidad Un modelo es lineal cuando cualquier valor de la variable dependiente o respuesta (\\(y_i\\)) es descrita por una combinación lineal de una serie de parámetros (coeficientes de la pendiente, intercepto). \\(Y \\approx \\beta _0 + \\beta _1X_1 + ... + \\beta _n X_n + \\varepsilon\\) 4.4 Supuesto de Normalidad Hace referencia a la normalidad de los residuales del modelo. Este supuesto se puede estudiar de manera gráfica: check_model(regresion_simple) Los 2 primeros gráficos sirven para verificar el supuesto de normalidad de los residuales Los 2 gráficos del centro sirven para verificar el supuesto de la homogeneidad de la varianza El último gráfico sirve para verificar si hay una observación influyente. Una observación influyente es una observación que tiene una distancia de Cook mayor a 1. En este caso la observación 31 está cerca de ser una observación influyente pero no lo es, o en este caso no es considerada influyente aunque tiene una distancia de Cook más lata que el resto pero no supera el valor de 1. Miremos los gráficos de manera individual: check_model(regresion_simple, check = &quot;normality&quot;) También numéricamente: check_normality(regresion_simple) ## OK: residuals appear as normally distributed (p = 0.718). 4.5 Supuesto de Homocedasticidad de varianzas Extraemos el siguiente gráfico para mirar el comportamiento de los residuales: check_model(regresion_simple, check = &quot;ncv&quot;) Vemos que hay un incremento de la varianza en el último residual y se evidencia un patrón. Se puede verificar esto numéricamente: check_heteroscedasticity(regresion_simple) ## Warning: Heteroscedasticity (non-constant error variance) detected (p = 0.043). Note que el resultado refuerza la conclusión observada en el gráfico, es decir, hay un problema de no homogeneidad de varianzas. 4.6 Supuesto de Independencia Este supuesto se refiere a que los residuales deben ser independientes, es decir no estar autocorrelacionados. Los residuales están autocorrelacionados cuando las observaciones provienen de un diseño de muestreo que no permitió obtener observaciones independientes, es decir que el valor de una observación no depende de la anterior. esto es común en series de timepo, cuando una variable se mide a lo largo del tiempo. check_autocorrelation(regresion_simple) ## OK: Residuals appear to be independent and not autocorrelated (p = 0.078). Ahora pasemos a resolver el problema de la falta de homogeneidad de varianza 4.7 Tecnicas para corregir la heterocedasticidad de varianzas Transformación de variables: la única que se recomienda logarítmica, pero las demás, no son buenas en la práctica por los problemas de interpretación que genera al modificar la variable. Los econometristas usan un modelos log - log aplicando log en ambos lados y se puede hacer una interpretación de tipo porcentual, cambio de porcentaje en el eje x, tiene un cambio en el porcentaje de y. Usar el paquete lmtest: los modelos siguientes corrigen la matriz de covarianzas, identificando el problema usando tecnicas complejas como lo es HC1, este método corrige y no se requiere verificación, a diferencia de los otros métodos de transformación de variables. Usar el paquete gls: generalized leat squares # vcov matriz de covarianzas. Hay varias opciones HC1, HC2, etc. Esto es un métdo de sandwich con un estimador de White, más sencillo en bayesiana coeftest(regresion_simple, vcov = vcovHC(regresion_simple, &quot;HC1&quot;)) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -1.046112 0.111866 -9.3515 2.954e-10 *** ## dap 0.056475 0.003530 15.9988 6.296e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Se pueden conocer los intervalos de confianza: coefci(regresion_simple, vcov = vcovHC(regresion_simple, &quot;HC1&quot;)) ## 2.5 % 97.5 % ## (Intercept) -1.27490335 -0.8173214 ## dap 0.04925587 0.0636951 Acá se interpreta el tamño del efecto usando el IC: por cada 1 \\(cm\\) que aumenta el \\(dap\\), el \\(volumen\\) de los árboles aumentarán entre 0.04925587 y 0.0636951 \\(m^{3}\\). Ahora podemos realizar un gráfico de nuestro modelo pero teniendo en consideración: plot_model(regresion_simple, type = &quot;pred&quot;, vcov.type = &quot;HC1&quot;) Este es el gráfico del modelo con un intervalode confianza al 95% La intepretación del modelo sería la siguiente: La variable dap presentó una relación positiva con el volumen y se considera estadísticamente signigificativa (\\(\\alpha = 0.05\\)), por cada \\(1 cm\\) en el incremento del \\(dap\\), el \\(volumen\\) se incrementó \\(0.06\\), \\(EE = 0.004\\), \\(95% IC [0.05, 0.06]\\), \\(p &lt; 0.001\\). El modelo explicó una parte sustancial de la varianza (\\(R^2 = 0.93\\)). "],["herramientas-para-visualizar-datos.html", "5 Herramientas para visualizar datos 5.1 Chunk de librerías 5.2 Carga de la base de datos", " 5 Herramientas para visualizar datos Las siguientes herramientas, permiten conocer rápidamente las características de la base de datos con la que estamos trabajando 5.1 Chunk de librerías library(visdat) # Paquete con varias herramientas para visualizar datos library(DataExplorer) #Para usar la función plot_missing 5.2 Carga de la base de datos data(&quot;airquality&quot;) #Base de datos con variables que estudian la calidad del aire vis_dat(airquality) Si se desea, se pueden omitir los datos NA ßßßßß aire &lt;- na.omit(airquality) vis_dat(aire) plot_missing(airquality) # Me indica si tenemos datos en blanco y me da una recomendación, que en este caso dice que es &quot;a&quot;, lo cual no es mucho problema "],["visualización-de-datos-con-ggplot2.html", "6 Visualización de Datos con ggplot2", " 6 Visualización de Datos con ggplot2 Cargamos los datos Datos_Enoc.csv, que contienen información sobre pasos realizados, elementos repetidos y la cantidad de veces que estos se repiten. Utilizamos la función read.csv() para leer los datos desde un archivo CSV. datos &lt;- read.csv(&quot;Data/Datos_Enoc.csv&quot;, header = TRUE, sep = &quot;;&quot;, dec = &quot;.&quot;) datos ## TotalPasos ElementoRepetido CantidadDeVeces ## 1 515 10 4 ## 2 516 3 4 ## 3 511 6 3 ## 4 514 9 4 ## 5 517 1 4 ## 6 521 7 5 ## 7 524 9 5 ## 8 524 4 4 ## 9 516 8 4 ## 10 517 1 5 Para empezar, cargamos la librería ggplot2, que nos permitirá realizar gráficos de alta calidad. library(ggplot2) Luego, creamos un gráfico de dispersión utilizando las variables ElementoRepetido y TotalPasos, con el tamaño de los puntos determinado por la variable CantidadDeVeces. ggplot(datos, aes(ElementoRepetido, TotalPasos)) + geom_point(aes(size = CantidadDeVeces)) ggplot(datos, aes(ElementoRepetido, TotalPasos)): Creamos un objeto gráfico base con los datos, donde asignamos el eje X a la variable ElementoRepetido y el eje Y a TotalPasos. Esto especifica las coordenadas para cada punto en el gráfico. geom_point(aes(size = CantidadDeVeces)): Añadimos los puntos al gráfico, y usamos el tamaño de los puntos (parámetro size) para representar CantidadDeVeces. Cuanto mayor es el valor de CantidadDeVeces, más grande será el punto en el gráfico. Luego, se puede visualizar el mismo gráfico, pero ahora agregando color a los puntos basado en la variable CantidadDeVeces para hacer la visualización más intuitiva. str(datos) ## &#39;data.frame&#39;: 10 obs. of 3 variables: ## $ TotalPasos : int 515 516 511 514 517 521 524 524 516 517 ## $ ElementoRepetido: int 10 3 6 9 1 7 9 4 8 1 ## $ CantidadDeVeces : int 4 4 3 4 4 5 5 4 4 5 ggplot(datos, aes(ElementoRepetido, TotalPasos)) + geom_point(aes(color = CantidadDeVeces)) + theme_minimal() * geom_point(aes(color = CantidadDeVeces)): En lugar de cambiar el tamaño de los puntos, ahora usamos el parámetro color para que los puntos cambien de color según el valor de CantidadDeVeces. theme_minimal(): Aplica un tema visual limpio y simple al gráfico, eliminando elementos innecesarios para centrar la atención en los datos. Para mejorar la interpretación de las variables categóricas, transformamos ElementoRepetido y CantidadDeVeces en factores. Aquí usamos factor() para convertir ElementoRepetido en una variable categórica (factor). Luego verificamos la estructura de los datos con str() para asegurarnos de que el cambio se realizó correctamente. datos$ElementoRepetido &lt;- factor(datos$ElementoRepetido) str(datos) ## &#39;data.frame&#39;: 10 obs. of 3 variables: ## $ TotalPasos : int 515 516 511 514 517 521 524 524 516 517 ## $ ElementoRepetido: Factor w/ 8 levels &quot;1&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,..: 8 2 4 7 1 5 7 3 6 1 ## $ CantidadDeVeces : int 4 4 3 4 4 5 5 4 4 5 ggplot(datos, aes(x = ElementoRepetido, y = TotalPasos)) + geom_bar(stat=&quot;identity&quot;, position=position_dodge(),aes(fill = CantidadDeVeces)) + theme_minimal() Creamos un gráfico de barras para visualizar los TotalPasos según el ElementoRepetido, con barras coloreadas según CantidadDeVeces. * geom_bar(stat = “identity”): Crea un gráfico de barras donde la altura de las barras corresponde a los valores de TotalPasos. aes(fill = CantidadDeVeces): Coloreamos las barras según el valor de CantidadDeVeces para representar la frecuencia de cada categoría. position_dodge(): Alinea las barras una al lado de la otra en lugar de superponerlas, facilitando la comparación entre categorías. Finalmente, creamos un gráfico de dispersión con colores y ajustamos etiquetas para hacerlo más informativo. datos$CantidadDeVeces &lt;- factor(datos$CantidadDeVeces) datos$ElementoRepetido &lt;- factor(datos$ElementoRepetido) ggplot(datos, aes(x= ElementoRepetido, y = TotalPasos)) + geom_point(aes(color = CantidadDeVeces)) + theme_minimal() + labs(title = &quot;Tiempo de ejecución por dato más frecuente&quot;, y = &quot;Total de pasos&quot;, x = &quot;Moda o dato más frecuente&quot;, label = &quot;N° de repeticiones&quot;) + scale_color_discrete(name=&quot;N° Repeticiones&quot;) labs(): Añade etiquetas y títulos al gráfico: title: Título del gráfico. y: Etiqueta del eje Y, indicando “Total de pasos”. x: Etiqueta del eje X, indicando “Moda o dato más frecuente”. scale_color_discrete(name = “N° Repeticiones”): Cambia la leyenda del gráfico para que el título de la leyenda sea “N° Repeticiones”. Este gráfico final muestra de manera clara cómo el ElementoRepetido afecta el TotalPasos, y usa el color para representar la cantidad de veces que cada elemento aparece. "],["gráficos-de-barras.html", "7 Gráficos de Barras 7.1 Requerimientos: 7.2 legend() siempre nos pide los siguientes argumentos. 7.3 Grafico de pastel 7.4 Gráfico de dona 7.5 Para practicar", " 7 Gráficos de Barras 7.1 Requerimientos: library(tidyverse) library(ggalt) # para graficar los lollipop library(datos) # bases de datos para trabajar library(nycflights13) library(dplyr) Comenzamos por cargar los datos desde el CSV, utilizando la función read.csv. Ahora generaremos gráficos de barras con los datos cargados utilizando la funcion de barplot(). Esta funcion crea gráficos de barras a partir de una matr4iz o conjunto de datos. Para mejorar el gráfico se pueden añadir etiquetas y colores, por otro lado se forma cada grupo de datos con el fin de que haya un cojunto de barras individuales datP26 &lt;- read.csv(&quot;Data/NM_P26h.csv&quot;, header=TRUE, sep=&#39;;&#39;, dec=&#39;,&#39;, row.names = 1) print(datP26) ## Pretest Postest ## TD 420 457 ## D 889 830 ## N 793 804 ## A 102 110 ## TA 71 68 ## NR 13 9 barplot(as.matrix(datP26)) barplot(as.matrix(datP26), xlab=&quot;Test aplicado&quot;, col=c(&quot;red&quot;, &quot;yellow&quot;,&quot;blue&quot;,&quot;orange&quot;,&quot;green&quot;,&quot;gray&quot;), beside = T, ylim=c(0, 1030), legend=row.names(datP26)) # Cambien beside = F barplot(as.matrix(datP26), xlab=&quot;Test aplicado&quot;, col=c(&quot;red&quot;, &quot;yellow&quot;,&quot;blue&quot;,&quot;orange&quot;,&quot;green&quot;,&quot;gray&quot;), beside = T, xlim=c(0, 1030), legend=row.names(datP26), horiz = T, width = 3) xlab=“Test aplicado”: Añade una etiqueta al eje X, en este caso “Test aplicado”. col=c(“red”, “yellow”, …): Define los colores de las barras. Cada barra tendrá un color diferente, representado en el vector de colores. beside = T: Establece que las barras deben aparecer una al lado de la otra en lugar de estar apiladas. ylim=c(0, 1030): Define los límites del eje Y, permitiendo que los valores en el gráfico se extiendan de 0 a 1030. legend=row.names(datP26): Añade una leyenda al gráfico utilizando los nombres de las filas de los datos como etiquetas para cada conjunto de barras. horiz = T: Cambia la orientación del gráfico para que las barras se dispongan horizontalmente. width = 3: Ajusta el ancho de las barras. En este otro segmento transponemos la matriz de datos apra intercambiar las filas por columnas y volver a generar el gráfico. datP26t &lt;-t(datP26) head(datP26t) ## TD D N A TA NR ## Pretest 420 889 793 102 71 13 ## Postest 457 830 804 110 68 9 barplot(as.matrix(datP26t), xlab=&quot;Test aplicado&quot;, col=c(&quot;blue&quot;,&quot;green&quot;), beside = T, ylim=c(0, 1030), legend=row.names(datP26t)) Dónde: t(datP26): La función t() transpone la matriz, es decir, intercambia las filas y las columnas. as.matrix(datP26t): Volvemos a convertir los datos transpuestos en una matriz para generar el gráfico. col=c(“blue”,“green”): En este caso, asignamos dos colores a las barras. 7.2 legend() siempre nos pide los siguientes argumentos. legend: Las etiquetas de los datos que queremos describir con la leyenda. Por ejemplo, si tenemos cuatro categorías a describir, proporcionamos un vector de cuatro cadenas de texto. fill: Los colores que acompañan a las etiquetas definidas con legend. Estos colores tienen que coincidir con los que hemos usado en el gráfico. x y y: Las coordenadas en pixeles, en las que estará ubicada la leyenda. Podemos dar como argumento a x alguno de los siguientes argumentos, para ubicar automáticamente la leyenda: “bottomright”, “bottom”, “bottomleft”, “left”, “topleft”, “top”, “topright”, “right”, “center”. title: Para poner título a la leyenda. millas_clase &lt;- millas$clase millas_clase ## [1] &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; ## [6] &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; ## [11] &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; ## [16] &quot;mediano&quot; &quot;mediano&quot; &quot;mediano&quot; &quot;suv&quot; &quot;suv&quot; ## [21] &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; &quot;2asientos&quot; &quot;2asientos&quot; ## [26] &quot;2asientos&quot; &quot;2asientos&quot; &quot;2asientos&quot; &quot;suv&quot; &quot;suv&quot; ## [31] &quot;suv&quot; &quot;suv&quot; &quot;mediano&quot; &quot;mediano&quot; &quot;mediano&quot; ## [36] &quot;mediano&quot; &quot;mediano&quot; &quot;minivan&quot; &quot;minivan&quot; &quot;minivan&quot; ## [41] &quot;minivan&quot; &quot;minivan&quot; &quot;minivan&quot; &quot;minivan&quot; &quot;minivan&quot; ## [46] &quot;minivan&quot; &quot;minivan&quot; &quot;minivan&quot; &quot;pickup&quot; &quot;pickup&quot; ## [51] &quot;pickup&quot; &quot;pickup&quot; &quot;pickup&quot; &quot;pickup&quot; &quot;pickup&quot; ## [56] &quot;pickup&quot; &quot;pickup&quot; &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; ## [61] &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; &quot;pickup&quot; ## [66] &quot;pickup&quot; &quot;pickup&quot; &quot;pickup&quot; &quot;pickup&quot; &quot;pickup&quot; ## [71] &quot;pickup&quot; &quot;pickup&quot; &quot;pickup&quot; &quot;pickup&quot; &quot;suv&quot; ## [76] &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; ## [81] &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; &quot;pickup&quot; &quot;pickup&quot; ## [86] &quot;pickup&quot; &quot;pickup&quot; &quot;pickup&quot; &quot;pickup&quot; &quot;pickup&quot; ## [91] &quot;subcompacto&quot; &quot;subcompacto&quot; &quot;subcompacto&quot; &quot;subcompacto&quot; &quot;subcompacto&quot; ## [96] &quot;subcompacto&quot; &quot;subcompacto&quot; &quot;subcompacto&quot; &quot;subcompacto&quot; &quot;subcompacto&quot; ## [101] &quot;subcompacto&quot; &quot;subcompacto&quot; &quot;subcompacto&quot; &quot;subcompacto&quot; &quot;subcompacto&quot; ## [106] &quot;subcompacto&quot; &quot;subcompacto&quot; &quot;subcompacto&quot; &quot;mediano&quot; &quot;mediano&quot; ## [111] &quot;mediano&quot; &quot;mediano&quot; &quot;mediano&quot; &quot;mediano&quot; &quot;mediano&quot; ## [116] &quot;subcompacto&quot; &quot;subcompacto&quot; &quot;subcompacto&quot; &quot;subcompacto&quot; &quot;subcompacto&quot; ## [121] &quot;subcompacto&quot; &quot;subcompacto&quot; &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; ## [126] &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; ## [131] &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; ## [136] &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; ## [141] &quot;suv&quot; &quot;compacto&quot; &quot;compacto&quot; &quot;mediano&quot; &quot;mediano&quot; ## [146] &quot;mediano&quot; &quot;mediano&quot; &quot;mediano&quot; &quot;mediano&quot; &quot;mediano&quot; ## [151] &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; &quot;mediano&quot; ## [156] &quot;mediano&quot; &quot;mediano&quot; &quot;mediano&quot; &quot;mediano&quot; &quot;suv&quot; ## [161] &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; ## [166] &quot;subcompacto&quot; &quot;subcompacto&quot; &quot;subcompacto&quot; &quot;subcompacto&quot; &quot;compacto&quot; ## [171] &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; &quot;suv&quot; &quot;suv&quot; ## [176] &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; &quot;suv&quot; &quot;mediano&quot; ## [181] &quot;mediano&quot; &quot;mediano&quot; &quot;mediano&quot; &quot;mediano&quot; &quot;mediano&quot; ## [186] &quot;mediano&quot; &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; ## [191] &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; ## [196] &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; &quot;suv&quot; &quot;suv&quot; ## [201] &quot;pickup&quot; &quot;pickup&quot; &quot;pickup&quot; &quot;pickup&quot; &quot;pickup&quot; ## [206] &quot;pickup&quot; &quot;pickup&quot; &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; ## [211] &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; ## [216] &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; ## [221] &quot;compacto&quot; &quot;subcompacto&quot; &quot;subcompacto&quot; &quot;subcompacto&quot; &quot;subcompacto&quot; ## [226] &quot;subcompacto&quot; &quot;subcompacto&quot; &quot;mediano&quot; &quot;mediano&quot; &quot;mediano&quot; ## [231] &quot;mediano&quot; &quot;mediano&quot; &quot;mediano&quot; &quot;mediano&quot; table(millas_clase) ## millas_clase ## 2asientos compacto mediano minivan pickup subcompacto ## 5 47 41 11 33 35 ## suv ## 62 barplot(table(millas_clase), xlab=&quot;Test aplicado&quot;, col=c(&quot;red&quot;, &quot;yellow&quot;,&quot;blue&quot;,&quot;orange&quot;,&quot;green&quot;,&quot;gray&quot;), beside = T, ylim=c(0, 100)) legend(x = &quot;topright&quot;, legend=row.names(table(millas_clase)), fill = c(&quot;red&quot;, &quot;yellow&quot;,&quot;blue&quot;,&quot;orange&quot;,&quot;green&quot;,&quot;gray&quot;)) summary(millas_clase) ## Length Class Mode ## 234 character character str(millas) ## tibble [234 × 11] (S3: tbl_df/tbl/data.frame) ## $ fabricante : chr [1:234] &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; ... ## $ modelo : chr [1:234] &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; ... ## $ cilindrada : num [1:234] 1.8 1.8 2 2 2.8 2.8 3.1 1.8 1.8 2 ... ## $ anio : int [1:234] 1999 1999 2008 2008 1999 1999 2008 1999 1999 2008 ... ## $ cilindros : int [1:234] 4 4 4 4 6 6 6 4 4 4 ... ## $ transmision: chr [1:234] &quot;auto(l5)&quot; &quot;manual(m5)&quot; &quot;manual(m6)&quot; &quot;auto(av)&quot; ... ## $ traccion : chr [1:234] &quot;d&quot; &quot;d&quot; &quot;d&quot; &quot;d&quot; ... ## $ ciudad : int [1:234] 18 21 20 21 16 18 18 18 16 20 ... ## $ autopista : int [1:234] 29 29 31 30 26 26 27 26 25 28 ... ## $ combustible: chr [1:234] &quot;p&quot; &quot;p&quot; &quot;p&quot; &quot;p&quot; ... ## $ clase : chr [1:234] &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; &quot;compacto&quot; ... Entre las variables de millas se encuentran: motor: tamaño del motor del automóvil, en litros. autopista: eficiencia del uso de combustible de un automóvil encarretera, en millas por galón. Al recorrer la misma distancia, un automóvil de baja eficiencia consume más combustible que un automóvil de alta eficiencia. Formato General: ggplot(data = ) + (mapping = aes()) A continuación, echemos un vistazo a un gráfico de barras. Los gráficos de barras parecen simples, pero son interesantes porque revelan algo sutil sobre los gráficos. Considera un gráfico de barras básico, como uno realizado con geom_bar(). El siguiente gráfico muestra la cantidad total de diamantes en el conjunto de datos diamantes, agrupados por la variable corte. El conjunto de datos diamantes se encuentra en el paquete datos y contiene información sobre 54000 diamantes, incluido el precio, el quilate, el color, la claridad y el corte de cada uno. El gráfico muestra que hay más diamantes disponibles con cortes de alta calidad que con cortes de baja calidad. str(diamantes) ## tibble [53,940 × 10] (S3: tbl_df/tbl/data.frame) ## $ precio : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ... ## $ quilate : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ... ## $ corte : Ord.factor w/ 5 levels &quot;Regular&quot;&lt;&quot;Bueno&quot;&lt;..: 5 4 2 4 2 3 3 3 1 3 ... ## $ color : Ord.factor w/ 7 levels &quot;D&quot;&lt;&quot;E&quot;&lt;&quot;F&quot;&lt;&quot;G&quot;&lt;..: 2 2 2 6 7 7 6 5 2 5 ... ## $ claridad : Ord.factor w/ 8 levels &quot;I1&quot;&lt;&quot;SI2&quot;&lt;&quot;SI1&quot;&lt;..: 2 3 5 4 2 6 7 3 4 5 ... ## $ profundidad: num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ... ## $ tabla : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ... ## $ x : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ... ## $ y : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ... ## $ z : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ... diamante &lt;- diamantes ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte)) ggplot(data = diamantes) + geom_bar(mapping = aes(x = claridad)) # aes: define una variable para la estética # + coord_flip() Si se desea ver solo las proporciones, en lugar de los valores netos: ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, y = ..prop.., group = 1)) ## Warning: The dot-dot notation (`..prop..`) was deprecated in ggplot2 3.4.0. ## ℹ Please use `after_stat(prop)` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. El siguiente gráfico muestras estadísticas resumen como máximo (max), mínimo (min) y la mediana de los datos profundidad, según clasificación por corte ggplot(data = diamantes) + stat_summary( mapping = aes(x = corte, y = profundidad), fun.ymin = min, fun.ymax = max, fun.y = median ) ## Warning: The `fun.y` argument of `stat_summary()` is deprecated as of ggplot2 3.3.0. ## ℹ Please use the `fun` argument instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. ## Warning: The `fun.ymin` argument of `stat_summary()` is deprecated as of ggplot2 3.3.0. ## ℹ Please use the `fun.min` argument instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. ## Warning: The `fun.ymax` argument of `stat_summary()` is deprecated as of ggplot2 3.3.0. ## ℹ Please use the `fun.max` argument instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. Para colorear los gráficos, se puede usar como referencia un vector, que podría ser alguna de las variables de la base de datos. Tome en cuenta que el parámetro colour se refiere al borde, pero si lo que desea es colorear la barra, debe usar fill ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, colour = corte)) ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, fill = corte)) Asignemos otra variable para fill. Las barras están apiladas: ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, fill = claridad)) El apilamiento se realiza automáticamente mediante el ajuste de posición especificado por el argumento position. Explore otras opciones para position: “identity”, “dodge”, “fill” ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, fill = claridad), position = &quot;jitter&quot;) # barras quedan superpuestas, una detrás de la otra. El alpha es para darle transparencia para que se vean las barras que están detrás. #ggplot(data = diamantes) + # geom_bar(mapping = aes(x = corte, colour = claridad, fill = claridad), position = &quot;jitter&quot;) ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, fill = claridad), position = &quot;fill&quot;) #explore con position = &quot;stack&quot; ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, fill = corte), position = &quot;dodge&quot;) # Puede cambiar la variables fill = corte por otra, por ejemplo, claridad Si se desean las barras horrizontales, se agrega la instrucción coord_flip() y automáticamente ordena las barras de mayor a menor ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, fill = corte), position = &quot;dodge&quot;) + coord_flip() bar &lt;- ggplot(data = diamantes) + geom_bar( mapping = aes(x = corte, fill = corte), show.legend = FALSE, width = 1 ) + theme(aspect.ratio = 1) + labs(x = NULL, y = NULL) bar + coord_flip() bar + coord_polar() bar &lt;- ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, fill = claridad), show.legend = F, width = 0.75) + theme(aspect.ratio = 1) + labs(x = NULL, y = NULL) bar + coord_flip() bar + coord_polar() diaman_dat &lt;- diamantes %&gt;% group_by(corte) %&gt;% # agrupar todo por clase summarise(conteo = n()) diaman_dat ## # A tibble: 5 × 2 ## corte conteo ## &lt;ord&gt; &lt;int&gt; ## 1 Regular 1610 ## 2 Bueno 4906 ## 3 Muy bueno 12082 ## 4 Premium 13791 ## 5 Ideal 21551 g6 &lt;- ggplot(diaman_dat, aes(y = reorder(corte, conteo), x = conteo)) g6 + geom_lollipop(point.colour = &quot;steelblue&quot;, point.size = 2, horizontal = TRUE) ## Warning: Using the `size` aesthetic with geom_segment was deprecated in ggplot2 3.4.0. ## ℹ Please use the `linewidth` aesthetic instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. Verticalmente: g6 &lt;- ggplot(diaman_dat, aes(y = conteo , x = reorder(corte, conteo))) g6 + geom_lollipop(point.colour = &quot;steelblue&quot;, point.size = 2) g6 &lt;- ggplot(diaman_dat, aes(y = conteo , x = reorder(corte, conteo))) g6 + geom_lollipop(point.colour = &quot;steelblue&quot;, point.size = 13, size = 1) + geom_text(aes(label = conteo), color = &quot;white&quot;) + theme_minimal() + xlab(&quot;Clase&quot;) + ylab(&quot;conteo&quot;) 7.3 Grafico de pastel Primero, agrupamos los datos por la variable color utilizando group_by() y calculamos el conteo para cada categoría con summarise(). group_by(color): Agrupa los datos del conjunto diamantes según la variable color. Cada grupo corresponderá a una categoría distinta de colores de diamantes. summarise(conteo = n()): Resume los datos calculando el número de observaciones (n()) en cada grupo, es decir, el conteo de diamantes de cada color. diaman_dat1 &lt;-diamantes %&gt;% group_by(color) %&gt;% # agrupar todo por clase summarise(conteo = n()) El código en R agrupa los datos de diamantes por la variable de corte, calcula el número de diamantes en cada categoría, y luego calcula el porcentaje que representa cada categoría. Además, organiza estos porcentajes y define la posición para las etiquetas dentro de un gráfico de pastel, lo que facilita la visualización de la proporción de cada categoría en el total de diamantes. diaman_dat &lt;-diamantes %&gt;% group_by(corte) %&gt;% # agrupar todo por clase de var corte summarise(conteo = n()) # hace un resumen de conteo de cada categ. diaman_dat ## # A tibble: 5 × 2 ## corte conteo ## &lt;ord&gt; &lt;int&gt; ## 1 Regular 1610 ## 2 Bueno 4906 ## 3 Muy bueno 12082 ## 4 Premium 13791 ## 5 Ideal 21551 count.data &lt;- diaman_dat %&gt;% arrange(desc(conteo)) %&gt;% mutate(porcent = round(conteo/sum(conteo)*100,1)) count.data ## # A tibble: 5 × 3 ## corte conteo porcent ## &lt;ord&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Ideal 21551 40 ## 2 Premium 13791 25.6 ## 3 Muy bueno 12082 22.4 ## 4 Bueno 4906 9.1 ## 5 Regular 1610 3 # Agregar posición de la etiqueta de porcentaje count.data &lt;- count.data %&gt;% arrange(desc(corte)) %&gt;% mutate(lab.ypos = cumsum(porcent) - 0.5*porcent) count.data ## # A tibble: 5 × 4 ## corte conteo porcent lab.ypos ## &lt;ord&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ideal 21551 40 20 ## 2 Premium 13791 25.6 52.8 ## 3 Muy bueno 12082 22.4 76.8 ## 4 Bueno 4906 9.1 92.6 ## 5 Regular 1610 3 98.6 Crearemos un grafico de pastel (pie) usando verbos de ggplot2 . A diferencia de los gráficos de barras, se podría pensar que existe una versión geom_ ´para los gráficos de pastel, pero en realidad un gráfico de pastel es una variación de una gráfico de barras en coordenadas polares. Key function: geom_bar() + coord_polar(). Agregar texto a las etiquetas: geom_text() Cambio del relleno del color de forma manual: scale_color_manual() Apply theme_void() para eliminar los ejes, el background, etc mycols &lt;- c(&quot;#0073C2FF&quot;, &quot;#EFC000FF&quot;, &quot;#868686FF&quot;, &quot;#CD534CFF&quot;, &quot;#00FF00&quot;) ggplot(count.data, aes(x = &quot;&quot;, y = porcent, fill = corte)) + geom_bar(width = 1, stat = &quot;identity&quot;, color = &quot;transparent&quot;) + coord_polar(&quot;y&quot;, start = 0)+ geom_text(aes(y = lab.ypos, label = porcent), color = &quot;white&quot;)+ scale_fill_manual(values = mycols) + theme_void() 7.4 Gráfico de dona Cambios a considerar: 1. x = 2 2. Eliminar width en geom_bar() 3. agregar xlim(0.5,2.5) El hoyo se crea con 1 y 3 ggplot(count.data, aes(x = 2, y = porcent, fill = corte)) + geom_bar(stat = &quot;identity&quot;, color = &quot;white&quot;) + coord_polar(&quot;y&quot;, start = 0)+ geom_text(aes(y = lab.ypos, label = porcent), color = &quot;white&quot;)+ scale_fill_manual(values = mycols) + theme_void()+ xlim (0.5,2.5) dat &lt;- datos :: vuelos str(dat) ## tibble [336,776 × 19] (S3: tbl_df/tbl/data.frame) ## $ anio : int [1:336776] 2013 2013 2013 2013 2013 2013 2013 2013 2013 2013 ... ## $ mes : int [1:336776] 1 1 1 1 1 1 1 1 1 1 ... ## $ dia : int [1:336776] 1 1 1 1 1 1 1 1 1 1 ... ## $ horario_salida : int [1:336776] 517 533 542 544 554 554 555 557 557 558 ... ## $ salida_programada : int [1:336776] 515 529 540 545 600 558 600 600 600 600 ... ## $ atraso_salida : num [1:336776] 2 4 2 -1 -6 -4 -5 -3 -3 -2 ... ## $ horario_llegada : int [1:336776] 830 850 923 1004 812 740 913 709 838 753 ... ## $ llegada_programada: int [1:336776] 819 830 850 1022 837 728 854 723 846 745 ... ## $ atraso_llegada : num [1:336776] 11 20 33 -18 -25 12 19 -14 -8 8 ... ## $ aerolinea : chr [1:336776] &quot;UA&quot; &quot;UA&quot; &quot;AA&quot; &quot;B6&quot; ... ## $ vuelo : int [1:336776] 1545 1714 1141 725 461 1696 507 5708 79 301 ... ## $ codigo_cola : chr [1:336776] &quot;N14228&quot; &quot;N24211&quot; &quot;N619AA&quot; &quot;N804JB&quot; ... ## $ origen : chr [1:336776] &quot;EWR&quot; &quot;LGA&quot; &quot;JFK&quot; &quot;JFK&quot; ... ## $ destino : chr [1:336776] &quot;IAH&quot; &quot;IAH&quot; &quot;MIA&quot; &quot;BQN&quot; ... ## $ tiempo_vuelo : num [1:336776] 227 227 160 183 116 150 158 53 140 138 ... ## $ distancia : num [1:336776] 1400 1416 1089 1576 762 ... ## $ hora : num [1:336776] 5 5 5 5 6 5 6 6 6 6 ... ## $ minuto : num [1:336776] 15 29 40 45 0 58 0 0 0 0 ... ## $ fecha_hora : POSIXct[1:336776], format: &quot;2013-01-01 05:00:00&quot; &quot;2013-01-01 05:00:00&quot; ... table(dat$hora) ## ## 1 5 6 7 8 9 10 11 12 13 14 15 16 ## 1 1953 25951 22821 27242 20312 16708 16033 18181 19956 21706 23888 23002 ## 17 18 19 20 21 22 23 ## 24426 21783 21441 16739 10933 2639 1061 7.5 Para practicar Cargue el paquete datos en R el cual contiene varias bases de datos que pueden ser utilizadas para el trabajo con los temas del curso. Trabaje con los datos de vuelos y realice lo siguiente: Brevemente explique de qué tratan los datos Realice un gráfico de barras verticales con alguna de las variables presentes en el dataset vuelos. Esta variable debe cumplir los requerimientos explicados en clase 4.Realice un gráfico de barras horizontal con alguna de las variables. Al igual que el caso anterior, debe elegir una variable que se ajuste a los requerimientos discutidos en clase para este tipo de gráficos. 5.Elija una de las variables y construya un gráfico de pastel. La variable debe tener las condiciones apropiadas. Tome en cuenta que para cada gráfico debe considerar las recomendaciones estudiadas en clases, las cuáles las pueden encontrar en la presentación. Para cada uno de los gráficos, haga una breve interpretación de lo observado. Nota: es posible que tengan un problema para cargar la base de datos vuelos, debido a que se requiere del paquete nycflights13. "],["diagramas-de-cajas-boxplots.html", "8 Diagramas de cajas (Boxplots) 8.1 Chunk para librerías 8.2 Pie Chart 8.3 Paleta de colores 8.4 Diagrama de cajas", " 8 Diagramas de cajas (Boxplots) Primeramente se cargan algunas de las librerías a utilizar 8.1 Chunk para librerías library(mosaicData) # Paquete que contiene bases de datos library(ggplot2) # paquete graficador de alto desempeño library(colorspace) # Paleta de colores Se presenta un ejemplo con gráfico de pastel 8.2 Pie Chart Se genera un gráfico de pastel simple con sectores etiquetados y coloreados: grupos &lt;- c(18, 30, 32, 10, 10) etiquetas &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;F&quot;) pie(grupos,etiquetas,col=c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;, &quot;orange&quot;)) Los sectores no cumplen las condiciones estudiadas, porque no están ordendos los porcentajes de forma descendente: colmuestra &lt;- qualitative_hcl(5, &quot;Dark 3&quot;) colmuestra ## [1] &quot;#E16A86&quot; &quot;#AA9000&quot; &quot;#00AA5A&quot; &quot;#00A6CA&quot; &quot;#B675E0&quot; is.vector(colmuestra) ## [1] TRUE grupos &lt;- c(32, 30, 18, 10, 10) etiquetas &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;) pie(grupos,etiquetas,col= colmuestra, clockwise = T) 8.3 Paleta de colores En r se pueden utilizar múltiples gamas de colores. Para conocer las posibilidades, es bueno explorar la paleta de colores. En el ejemplo anterior, se escogió un gama de colores y se extrajo una muestra en forma de vector, esto porque los comandos de gráfico requieren usualmente, un vector de colores para el parámetro fill o colour hcl_palettes(plot = TRUE) 8.4 Diagrama de cajas Se usará la base de datos que trae R por defecto llamada Iris, la cuál contine información sobre el ancho y largo de sépalo y pétalo. floriris &lt;- iris str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... boxplot(Sepal.Length ~ Species, data = iris,ylab = &quot;Largo Sepalo (cm)&quot;, main = &quot;Medidas en la Tabla Iris&quot;,boxwex = 0.5,col=&quot;red&quot;) Sepal.Length ~ Species: Especifica la relación entre la longitud del sépalo y la especie de flor. data: El conjunto de datos iris. ylab, main: Etiquetas para el eje Y y el título del gráfico. boxwex: Define el ancho de las cajas. col: Color de las cajas. boxplot(Sepal.Length~Species, data=iris,col=c(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;)) En el caso de virgínica, se puede detectar un dato atípico en la parte inferior del gráfico de caja Seguidamente se trabajará con un ejemplo de una base de datos tomada del paquete mosaicData, que contie datos de vivienda de la comunidad de Saratoga County, New York, USA, 2006 casas &lt;- SaratogaHouses # graficos descriptivos cuandoe en el eje x tengo una variable categórica g1 &lt;- ggplot(casas, aes(centralAir, price)) g1 + geom_boxplot(alpha = 0.4, color = &quot;blue&quot;) # Los puntos azules no son datos crudos, son puntos del Boxplot, los outliers o valores atípicos aes(centralAir, price): Relaciona el sistema de aire acondicionado con el precio de las casas. geom_boxplot(): Añade el gráfico de cajas al gráfico base. alpha: Controla la transparencia del gráfico. color: Define el color de las cajas. # graficos descriptivos cuandoe en el eje x tengo una variable categórica gg1 &lt;- ggplot(casas, aes(centralAir, price)) gg1 + geom_jitter(width = 0.3, alpha = 0.4) + geom_boxplot(alpha = 0.4, color = &quot;blue&quot;) # Los puntos azules no son datos crudos, son puntos del Boxplot, los outliers o valores atípicos También se combinan gráficos de dispersión (jitter) con gráficos de cajas y violines para una visualización más completa de los datos: gg1 + geom_jitter(width = 0.3, alpha = 0.4) + geom_boxplot(alpha = 0.4, color = &quot;blue&quot;) + geom_violin(aes(alpha = 0.3, fill = centralAir)) geom_jitter(): Añade puntos dispersos al gráfico para representar la distribución de los datos. geom_violin(): Añade un gráfico de violín para mostrar la densidad de los datos. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
